type Account {
  id: ID!
  name: String!
  created_at: DateTimeTz!
  updated_at: DateTimeTz!
  user: User!
}

type AuthPayload {
  access_token: String
  refresh_token: String
  expires_in: Int
  token_type: String
  user: User
}

type Category {
  id: ID!
  name: String!
  user: User!
  created_at: DateTimeTz!
  updated_at: DateTimeTz!
}

input CreateAccountInput {
  name: String!
}

input CreateCategoryInput {
  name: String!
}

input CreateIncomeInput {
  category_id: ID!
  account_id: ID!
  date: Date!
  amount: Float!
  description: String
}

"""A date string with format `Y-m-d`, e.g. `2011-05-23`."""
scalar Date

"""
A datetime string with format `Y-m-d H:i:s`, e.g. `2018-01-01 13:00:00`.
"""
scalar DateTime

"""
A datetime and timezone string in ISO 8601 format `Y-m-dTH:i:sO`, e.g. `2020-04-20T13:53:12+02:00`.
"""
scalar DateTimeTz

input ForgotPasswordInput {
  email: String!
}

type ForgotPasswordResponse {
  status: String!
  message: String
}

type Income {
  id: ID!
  user: User!
  category: Category!
  account: Account!
  date: Date!
  amount: Float!
  description: String
  created_at: DateTimeTz!
  updated_at: DateTimeTz!
}

"""A paginated list of Income edges."""
type IncomeConnection {
  """Pagination information about the list of edges."""
  pageInfo: PageInfo!

  """A list of Income edges."""
  edges: [IncomeEdge]
}

"""An edge that contains a node of type Income and a cursor."""
type IncomeEdge {
  """The Income node."""
  node: Income

  """A unique cursor that can be used for pagination."""
  cursor: String!
}

input LoginInput {
  username: String!
  password: String!
}

type LogoutResponse {
  status: String!
  message: String
}

"""
Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
as they may not be parsed correctly on the server side. Use `String` literals if you are
dealing with really large numbers to be on the safe side.
"""
scalar Mixed

type Mutation {
  createAccount(input: CreateAccountInput!): Account
  updateAccount(id: ID!, input: UpdateAccountInput!): Account
  deleteAccount(id: ID!): Account
  createCategory(input: CreateCategoryInput!): Category
  updateCategory(id: ID!, input: UpdateCategoryInput!): Category
  deleteCategory(id: ID!): Category
  createIncome(input: CreateIncomeInput!): Income
  updateIncome(id: ID!, input: UpdateIncomeInput!): Income
  deleteIncome(id: ID!): Income
  login(input: LoginInput): AuthPayload!
  refreshToken(input: RefreshTokenInput): RefreshTokenPayload!
  logout: LogoutResponse!
  forgotPassword(input: ForgotPasswordInput!): ForgotPasswordResponse!
  updateForgottenPassword(input: NewPasswordWithCodeInput): ForgotPasswordResponse!
  register(input: RegisterInput): RegisterResponse!
  socialLogin(input: SocialLoginInput!): AuthPayload!
  verifyEmail(input: VerifyEmailInput!): AuthPayload!
  updatePassword(input: UpdatePassword!): UpdatePasswordResponse!
}

input NewPasswordWithCodeInput {
  email: String!
  token: String!
  password: String!
  password_confirmation: String!
}

"""Allows ordering a list of records."""
input OrderByClause {
  """The column that is used for ordering."""
  field: String!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""Pagination information about the corresponding list of items."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """Total number of node in connection."""
  total: Int

  """Count of nodes in current request."""
  count: Int

  """Current page of request."""
  currentPage: Int

  """Last page in connection."""
  lastPage: Int
}

"""Pagination information about the corresponding list of items."""
type PaginatorInfo {
  """Total count of available items in the page."""
  count: Int!

  """Current pagination page."""
  currentPage: Int!

  """Index of first item in the current page."""
  firstItem: Int

  """If collection has more pages."""
  hasMorePages: Boolean!

  """Index of last item in the current page."""
  lastItem: Int

  """Last page number of the collection."""
  lastPage: Int!

  """Number of items per page in the collection."""
  perPage: Int!

  """Total items available in the collection."""
  total: Int!
}

type Query {
  accounts: [Account!]
  account(id: ID!): Account!
  categories: [Category!]
  category(id: ID!): Category!
  incomes(
    """Limits number of fetched elements."""
    first: Int!

    """A cursor after which elements are returned."""
    after: String
  ): IncomeConnection
  income(id: ID!): Income!
}

input RefreshTokenInput {
  refresh_token: String
}

type RefreshTokenPayload {
  access_token: String!
  refresh_token: String!
  expires_in: Int!
  token_type: String!
}

input RegisterInput {
  name: String!
  email: String!
  password: String!
  password_confirmation: String!
}

type RegisterResponse {
  tokens: AuthPayload
  status: RegisterStatuses!
}

enum RegisterStatuses {
  MUST_VERIFY_EMAIL
  SUCCESS
}

"""The available SQL operators that are used to filter query results."""
enum SQLOperator {
  """Equal operator (`=`)"""
  EQ

  """Not equal operator (`!=`)"""
  NEQ

  """Greater than operator (`>`)"""
  GT

  """Greater than or equal operator (`>=`)"""
  GTE

  """Less than operator (`<`)"""
  LT

  """Less than or equal operator (`<=`)"""
  LTE

  """Simple pattern matching (`LIKE`)"""
  LIKE

  """Negation of simple pattern matching (`NOT LIKE`)"""
  NOT_LIKE

  """Whether a value is within a set of values (`IN`)"""
  IN

  """Whether a value is not within a set of values (`NOT IN`)"""
  NOT_IN

  """Whether a value is within a range of values (`BETWEEN`)"""
  BETWEEN

  """Whether a value is not within a range of values (`NOT BETWEEN`)"""
  NOT_BETWEEN

  """Whether a value is null (`IS NULL`)"""
  IS_NULL

  """Whether a value is not null (`IS NOT NULL`)"""
  IS_NOT_NULL
}

input SocialLoginInput {
  provider: String!
  token: String!
}

"""The available directions for ordering a list of records."""
enum SortOrder {
  """Sort records in ascending order."""
  ASC

  """Sort records in descending order."""
  DESC
}

"""
Specify if you want to include or exclude trashed results from a query.
"""
enum Trashed {
  """Only return trashed results."""
  ONLY

  """Return both trashed and non-trashed results."""
  WITH

  """Only return non-trashed results."""
  WITHOUT
}

input UpdateAccountInput {
  name: String!
}

input UpdateCategoryInput {
  name: String!
}

input UpdateIncomeInput {
  category_id: ID!
  account_id: ID!
  date: Date!
  amount: Float!
  description: String
}

input UpdatePassword {
  password: String!
  password_confirmation: String!
}

type UpdatePasswordResponse {
  status: String!
  message: String
}

type User {
  id: ID!
  name: String!
  email: String!
  created_at: DateTimeTz!
  updated_at: DateTimeTz!
  accounts: [Account!]
  categories: [Category!]
}

input VerifyEmailInput {
  token: String!
}

"""Dynamic WHERE conditions for queries."""
input WhereConditions {
  """The column that is used for the condition."""
  column: String

  """The operator that is used for the condition."""
  operator: SQLOperator = EQ

  """The value that is used for the condition."""
  value: Mixed

  """A set of conditions that requires all conditions to match."""
  AND: [WhereConditions!]

  """A set of conditions that requires at least one condition to match."""
  OR: [WhereConditions!]
}
